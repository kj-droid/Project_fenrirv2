# fenrir/modules/exploit_scanner.py
import asyncio
import shutil
import re
from ..logging_config import log

class ExploitScanner:
    """
    Searches for public exploits using the local SearchSploit database.
    """
    def __init__(self):
        log.debug("Exploit Scanner module initialized.")
        self.searchsploit_path = shutil.which("searchsploit")

    async def run(self, query: str):
        """
        Runs the exploit scan for a given search query.

        Args:
            query: The software, version, or CVE to search for.
        """
        log.info(f"Starting exploit search for query: '{query}'...")

        if not self.searchsploit_path:
            log.error("SearchSploit is not installed or not in your system's PATH.")
            log.error("Please install it (e.g., 'sudo apt install exploitdb') to use this feature.")
            return

        # Sanitize query to prevent command injection, although we are not using a shell.
        # We will pass arguments as a list to be safe.
        sanitized_query = query.split()
        command = [self.searchsploit_path, "-j"] + sanitized_query # -j for JSON output

        try:
            process = await asyncio.create_subprocess_exec(
                *command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await process.communicate()

            if process.returncode != 0:
                log.error(f"SearchSploit exited with an error: {stderr.decode().strip()}")
                return

            # In a future version, we would parse the JSON output (stdout) for a clean report.
            # For now, we will display the raw text output for simplicity.
            text_command = [self.searchsploit_path] + sanitized_query
            process_text = await asyncio.create_subprocess_exec(
                *text_command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout_text, _ = await process_text.communicate()
            
            output = stdout_text.decode().strip()

            # Check if any results were found
            if "Exploits: 0" in output or "No Results" in output:
                log.info(f"No public exploits found for '{query}'.")
            else:
                log.warning(f"Found potential exploits for '{query}':")
                # Clean up the output for better display
                lines = output.split('\n')
                # Find the line with the header separator '----------------'
                separator_index = -1
                for i, line in enumerate(lines):
                    if '----------------' in line:
                        separator_index = i
                        break
                
                if separator_index != -1:
                    # Print the header and the results
                    header = "\n".join(lines[separator_index-1:separator_index+1])
                    results = "\n".join(lines[separator_index+1:])
                    log.info(f"\n{header}")
                    log.warning(results)
                else:
                    # Fallback if separator not found
                    log.warning(output)


        except FileNotFoundError:
            log.error("SearchSploit command not found. Is it installed and in your PATH?")
        except Exception as e:
            log.error(f"An unexpected error occurred during exploit scan: {e}")
        
        log.info("Exploit search finished.")
